# FHIR-AI Backend Release Pipeline
# This workflow handles releases, versioning, and production deployments
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net

name: FHIR-AI Backend Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.0.0)'
        required: true
        default: '1.0.0'
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  DOTNET_VERSION: '8.0.x'
  SOLUTION_FILE: 'HealthTech.FHIR-AI.sln'
  REGISTRY: 'ghcr.io'
  IMAGE_NAME: '${{ github.repository }}'

jobs:
  # Version and Tag Job
  version-and-tag:
    name: Version and Tag
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Get version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          # Extract version from release tag
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        fi

    - name: Update version in project files
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        # Update version in Directory.Build.props or individual .csproj files
        find src -name "*.csproj" -exec sed -i "s/<Version>.*<\/Version>/<Version>$VERSION<\/Version>/g" {} \;
        find tests -name "*.csproj" -exec sed -i "s/<Version>.*<\/Version>/<Version>$VERSION<\/Version>/g" {} \;

    - name: Commit version changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "Bump version to ${{ steps.version.outputs.version }}" || exit 0
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release version ${{ steps.version.outputs.version }}"
        git push origin HEAD:${{ github.ref }} --tags

  # Build Release Job
  build-release:
    name: Build Release
    runs-on: ubuntu-latest
    needs: version-and-tag
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

  # Security Scan Release
  security-scan-release:
    name: Security Scan Release
    runs-on: ubuntu-latest
    needs: build-release

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-release.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-release, security-scan-release]
    if: github.event.inputs.environment == 'staging' || github.event_name == 'release'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to staging
      run: |
        echo "Deploying version ${{ needs.version-and-tag.outputs.version }} to staging"
        # Add your staging deployment logic here
        # Example: Deploy to Azure Container Instances, AWS ECS, etc.
        
        # Example for Azure Container Instances:
        # az container create \
        #   --resource-group fhir-ai-staging \
        #   --name fhir-ai-api \
        #   --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-release.outputs.image-tag }} \
        #   --dns-name-label fhir-ai-staging \
        #   --ports 80 443 \
        #   --environment-variables ASPNETCORE_ENVIRONMENT=Staging

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-release, security-scan-release]
    if: github.event.inputs.environment == 'production'
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to production
      run: |
        echo "Deploying version ${{ needs.version-and-tag.outputs.version }} to production"
        # Add your production deployment logic here
        # Example: Deploy to Azure Container Instances, AWS ECS, etc.
        
        # Example for Azure Container Instances:
        # az container create \
        #   --resource-group fhir-ai-production \
        #   --name fhir-ai-api \
        #   --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-release.outputs.image-tag }} \
        #   --dns-name-label fhir-ai-production \
        #   --ports 80 443 \
        #   --environment-variables ASPNETCORE_ENVIRONMENT=Production

  # Create Release Notes
  create-release-notes:
    name: Create Release Notes
    runs-on: ubuntu-latest
    needs: [version-and-tag, deploy-staging]
    if: github.event_name == 'release'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate release notes
      id: release_notes
      uses: actions/github-script@v7
      with:
        script: |
          const { data: commits } = await github.rest.repos.compareCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            base: 'main',
            head: context.sha
          });
          
          const releaseNotes = commits.commits
            .map(commit => `- ${commit.commit.message}`)
            .join('\n');
          
          core.setOutput('notes', releaseNotes);

    - name: Update release
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.updateRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: context.payload.release.id,
            body: `${{ steps.release_notes.outputs.notes }}\n\n## Docker Image\n\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-release.outputs.image-tag }}\`\n\n## Deployment\n- Staging: âœ… Deployed\n- Production: Manual deployment required`
          });

  # Notify Team
  notify-team:
    name: Notify Team
    runs-on: ubuntu-latest
    needs: [deploy-staging, create-release-notes]
    if: always()

    steps:
    - name: Notify on success
      if: success()
      run: |
        echo "Release ${{ needs.version-and-tag.outputs.version }} deployed successfully to staging"
        # Add notification logic here (Slack, Teams, Email, etc.)

    - name: Notify on failure
      if: failure()
      run: |
        echo "Release ${{ needs.version-and-tag.outputs.version }} deployment failed"
        # Add notification logic here (Slack, Teams, Email, etc.)
