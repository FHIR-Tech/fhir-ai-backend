---
description:
globs:
alwaysApply: true
---

# FHIR-AI Backend - Cursor AI Rules

This file defines comprehensive rules for Cursor AI when developing, scaffolding, and deploying the FHIR-AI Backend application.

## Project Overview
- **Technology Stack**: .NET 8, FHIR/HL7, PostgreSQL, Clean Architecture
- **Purpose**: HealthTech FHIR-compliant backend with AI integration capabilities
- **Architecture**: Multi-tenant, secure, scalable healthcare data platform

## Core Architecture Principles

### 1. Clean Architecture Implementation
- **Layers**: Domain → Application → Integration → Infrastructure → API
- **Dependencies**: Only inward (Domain has no external dependencies)
- **Namespace Pattern**: `HealthTech.{Layer}.{Feature}`

### 2. FHIR Compliance & Standards
- **FHIR Resources**: Stored in PostgreSQL JSONB with GIN indexes
- **Multi-tenancy**: Row-Level Security (RLS) by tenant
- **HL7 v2 Integration**: NHapi for parsing, Firely SDK for FHIR mapping
- **SMART on FHIR**: OAuth2/OpenID Connect authentication with scope enforcement

### 3. Security & Compliance
- **Authentication**: SMART on FHIR (patient/*, user/*, system/* scopes)
- **Data Protection**: pgcrypto encryption for sensitive columns
- **Audit Trail**: FHIR `AuditEvent` resources, append-only logging
- **Privacy**: No PII in application logs
- **RLS**: Mandatory Row-Level Security in production

## Development Rules

### 1. CQRS Pattern Implementation
- **Commands/Queries**: Use MediatR for all use cases
- **Naming**: `VerbNounCommand`, `VerbNounQuery`
- **Validation**: FluentValidation for all handlers
- **Immutability**: Use records for DTOs

### 2. API Design Standards
- **Framework**: Minimal APIs with ProblemDetails for errors
- **Endpoints**: All FHIR endpoints under `/fhir/...`
- **Error Handling**: Consistent error responses with proper HTTP status codes
- **Documentation**: OpenAPI/Swagger documentation for all endpoints

### 3. Data Access Patterns
- **Repository Pattern**: Domain layer contains only business rules
- **No Direct DB Access**: API layer must go through Application layer
- **EF Core**: Used only in Infrastructure layer
- **Database**: PostgreSQL with JSONB for FHIR resources

## Deployment & Infrastructure Rules

### 1. Containerization
- **Docker**: Multi-stage builds for optimized images
- **Health Checks**: Implement proper health check endpoints
- **Environment Variables**: Use configuration providers for all settings
- **Secrets Management**: Never hardcode sensitive information

### 2. Database Deployment
- **Migrations**: Use EF Core migrations for schema changes
- **Connection Strings**: Environment-specific configuration
- **Backup Strategy**: Automated backups with point-in-time recovery
- **Performance**: Proper indexing strategy for JSONB queries

### 3. Security Deployment
- **HTTPS**: Mandatory TLS/SSL in production
- **CORS**: Configured for healthcare domain requirements
- **Rate Limiting**: Implement API rate limiting
- **Monitoring**: Security event logging and alerting

### 4. Testing Strategy
- **Unit Tests**: All handlers and business logic
- **Integration Tests**: PostgreSQL container-based testing
- **API Tests**: End-to-end FHIR resource testing
- **Security Tests**: Authentication and authorization validation

### 5. API Testing & Development Workflow
- **API Ports**: HTTP 5000 (redirects to HTTPS), HTTPS 5001 (primary)
- **Database Check**: Always verify PostgreSQL is running before starting API
- **API Startup**: Use `dotnet run` in `/src/HealthTech.API` directory in background mode
- **Process Management**: Kill existing dotnet processes before restarting
- **Health Check**: Verify API responds at `https://localhost:5001/health`
- **Test Scripts**: Use Node.js scripts in `/scripts/api/` directory
- **SSL Warnings**: Ignore self-signed certificate warnings in development
- **Swagger UI**: Access at `https://localhost:5001/swagger/index.html`

## Code Quality Standards

### 1. Naming Conventions
- **PascalCase**: Classes, methods, properties
- **camelCase**: Variables, parameters
- **UPPER_CASE**: Constants
- **snake_case**: PostgreSQL database objects (tables, columns, indexes, constraints)
- **Descriptive Names**: Self-documenting code

### 2. Code Organization & Structure
- **Field Grouping**: Group related fields together with logical separation
- **Method Organization**: Arrange methods in logical order (constructors, properties, public methods, private methods)
- **Logical Grouping**: Use regions or comments to separate different functional areas
- **Consistent Ordering**: Maintain consistent field and method ordering across similar classes
- **Separation of Concerns**: Keep related functionality grouped together

### 3. Documentation
- **XML Comments**: All public APIs
- **README**: Comprehensive setup and deployment instructions
- **Architecture**: Document design decisions and patterns
- **API Documentation**: OpenAPI specifications

### 4. Project Structure & File Organization

#### Documentation Structure (`/docs/`)
```
docs/
├── README.md                    # Project overview
├── INDEX.md                     # Master documentation index
├── api/                         # API Documentation
│   ├── README.md               # API overview and navigation
│   ├── specifications/         # Technical specifications
│   │   └── {resource-type}_specification.md
│   ├── guides/                 # Usage guides and tutorials
│   │   └── {feature}_guide.md
│   ├── reports/                # API implementation reports
│   │   └── {report-type}_{date}.md
│   └── examples/               # Code examples and samples
│       └── {use-case}_example.md
├── architecture/               # Architecture documentation
│   ├── decisions/             # Architecture Decision Records (ADRs)
│   └── diagrams/              # System diagrams and flows
├── cursor-agent/               # Cursor Agent Reports & Documentation
│   ├── README.md              # Cursor Agent overview
│   ├── reports/               # Implementation reports
│   │   ├── template_implementation_report.md
│   │   └── {feature}_{date}_report.md
│   ├── logs/                  # Session logs and transcripts
│   │   └── {session-type}_{date}_{time}.md
│   ├── decisions/             # AI-generated architecture decisions
│   │   └── ADR_{number}_{title}.md
│   └── tasks/                 # Task tracking and milestones
│       └── {task-type}_{date}_summary.md
└── deployment/                 # Deployment documentation
    ├── guides/                # Deployment guides
    └── configurations/        # Environment configs
```

#### Sample Data Organization (`/scripts/samples/`)
- **FHIR Bundle samples**: `/scripts/samples/bundles/`
- **Individual resource samples**: `/scripts/samples/resources/`
- **Test data**: `/scripts/samples/test-data/`

#### Scripts Organization (`/scripts/`)
- **Database scripts**: `/scripts/database/`
- **API testing scripts**: `/scripts/api/`
- **Deployment scripts**: `/scripts/deployment/`

#### Naming Conventions
- **Specifications**: `{resource-type}_specification.md`
- **Guides**: `{feature}_guide.md`
- **Reports**: `{report-type}_{date}.md`
- **Examples**: `{use-case}_example.md`
- **Samples**: `{resource-type}_{purpose}_{date}.json`
- **Logs**: `{session-type}_{date}_{time}.md`
- **Decisions**: `ADR_{number}_{title}.md`

### 5. Performance Considerations
- **Async/Await**: Use throughout for I/O operations
- **Caching**: Implement appropriate caching strategies
- **Database Optimization**: Efficient queries and indexing
- **Memory Management**: Proper disposal of resources

### 6. Cursor Agent Documentation Rules

#### When Creating Documentation
- **Always use templates**: Use `docs/cursor-agent/reports/template_implementation_report.md` for implementation reports
- **Include metadata**: Date, Agent name, Session ID, Status, Duration
- **Follow naming conventions**: Use exact patterns specified in naming conventions
- **Update index**: Always update `docs/INDEX.md` when adding new documentation
- **Cross-reference**: Link related documents and maintain traceability

#### When Generating Reports
- **Use structured format**: Follow the template structure exactly
- **Include technical details**: Architecture decisions, implementation approach, challenges
- **Document code quality**: Patterns used, testing coverage, validation results
- **Track metrics**: Performance impact, success metrics, issues found
- **Provide next steps**: Immediate actions, future improvements, recommendations

#### When Logging Sessions
- **Record session metadata**: Date, time, duration, agent version
- **Document decisions**: Architecture decisions, technology choices, implementation strategies
- **Track progress**: Task completion, milestone achievements, feature delivery
- **Maintain audit trail**: All changes, reasons, and outcomes

#### Documentation Quality Standards
- **Completeness**: All sections of templates must be filled
- **Accuracy**: Technical details must be precise and verifiable
- **Clarity**: Use clear, professional language
- **Consistency**: Follow established patterns and conventions
- **Traceability**: Link to related documents and code changes

## Forbidden Practices

### ❌ Never Do
- Let Domain layer depend on EF Core or NHapi
- Bypass Application layer for direct database access
- Disable RLS or audit logging in production
- Hardcode connection strings or secrets
- Skip validation in handlers
- Use synchronous I/O in async contexts
- Log sensitive patient information
- Disable HTTPS in production
- Place documentation files in root directory (except README.md)
- Mix sample data with source code
- Use generic names for sample files
- Create unstructured file hierarchies
- **Documentation violations**:
  - Create documentation without using proper templates
  - Skip metadata in reports (date, agent, status)
  - Use inconsistent naming conventions
  - Fail to update documentation index
  - Place API docs outside `/docs/api/` structure
  - Place Cursor Agent reports outside `/docs/cursor-agent/` structure
  - Create documentation without cross-references
  - Skip technical details in implementation reports

### ✅ Always Do
- Follow Clean Architecture principles
- Implement proper error handling
- Use dependency injection
- Write comprehensive tests
- Document public APIs
- Use secure coding practices
- Implement proper logging
- Follow FHIR standards
- Organize files in appropriate directories
- Use descriptive naming conventions
- Maintain clean project structure
- Keep documentation up-to-date
- **Documentation best practices**:
  - Use templates for all documentation creation
  - Include complete metadata in all reports
  - Follow exact naming conventions
  - Update documentation index immediately
  - Place files in correct directory structure
  - Cross-reference related documents
  - Include technical details and metrics
  - Maintain audit trail for all changes
  - Use professional language and formatting
  - Validate documentation completeness

## Environment Configuration

### Development
- **Database**: Local PostgreSQL or Docker container
- **Logging**: Console and file logging
- **Authentication**: Development certificates
- **CORS**: Allow localhost origins

### Staging
- **Database**: Staging PostgreSQL instance
- **Logging**: Structured logging with correlation IDs
- **Authentication**: Staging certificates
- **Monitoring**: Basic health checks

### Production
- **Database**: Production PostgreSQL with high availability
- **Logging**: Centralized logging with alerting
- **Authentication**: Production certificates and key rotation
- **Monitoring**: Comprehensive APM and security monitoring
- **Backup**: Automated daily backups with retention policies

## Deployment Checklist

### Pre-Deployment
- [ ] All tests passing
- [ ] Security scan completed
- [ ] Performance testing done
- [ ] Documentation updated
- [ ] Environment variables configured
- [ ] Database migrations tested

### Deployment
- [ ] Database migration executed
- [ ] Application deployed
- [ ] Health checks passing
- [ ] SSL certificates valid
- [ ] Monitoring configured
- [ ] Backup system verified

### Post-Deployment
- [ ] Smoke tests executed
- [ ] Performance metrics monitored
- [ ] Error logs reviewed
- [ ] Security audit completed
- [ ] User acceptance testing done

---

*This rule set ensures consistent, secure, and maintainable development and deployment of the FHIR-AI Backend application.*
